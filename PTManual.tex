\documentclass[10pt, a4paper, twocolumn]{article}

\input{structure.tex}

%----------------------------------------------------------------------------------------
%	INFORMACIÓN DEL MATERIAL
%----------------------------------------------------------------------------------------

\title{Primer acercamiento al desarrollo de Problem Types en GiD}

\author{
	\authorstyle{Luis G. Yáñez Rodríguez\textsuperscript{1}} % Authors
	\newline\newline
	\textsuperscript{1}\institution{[Aula CIMNE-UG] Universidad de Guanajuato, Guanajuato, México}\\
}



\date{Abril, 2018}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

\thispagestyle{firstpage}

%----------------------------------------------------------------------------------------
%	RESUMEN
%----------------------------------------------------------------------------------------

\lettrineabstract{Sin duda los modelos computacionales nos han permitido entender el mundo que nos rodea. Ya sea para explicar un fenómeno o poder predecirlo. Parte del éxito de estas soluciones es la presentación y visualización de los resultados numéricos (post proceso). Ya que estos se resumen en ``ceros y unos'' el post proceso pretende llevarlos al usuario de forma más atractiva. Existen muchos softwares que ayudan en esta etapa, pero entre ellos destaca uno en particular llamado GiD, The personal pre and post processor, desarrollado por el Centro Internacional de Métodos Numéricos en Ingenierías (CIMNE), el cual que permite trasladar un problema a la abstracción computacional.}

\section{Justificación}

Cuando se usa GiD para un análisis en particular, es necesario establecer los parámetros a los que el modelo estará sujeto (pre proceso). En esta parte se definen las condiciones, materiales, datos generales, sistema de unidades, símbolos y el formato del archivo de salida para el solver\footnote{Conjunto técnicas matemáticas implementadas en un lenguaje de programación para resolver un problema numérico en específico.}. Gracias a la característica de adaptación de \textit{GiD} se puede definir una colección de archivos llamada \textbf{Problem Type} que establecen los parámetros anteriores de manera visual. Actualmente la documentación disponible acerca del desarrollo de problem types se encuentra en idioma inglés lo cual puede ser una limitante para aquellos que quieran incursionar en estas herramientas. 

\begin{figure}[hbt!]\centering
	\includegraphics[width=0.3\textwidth]{logoGiD.PNG}
	\caption{Logo de software GiD.}
\end{figure}

\subsection{Objetivo}

Este documento pretende ser un ``primer acercamiento'' a la personalización del software GiD dirigido a personas de habla hispana en donde encuentren los pasos básicos para crear un problem type.

\subsection{Aplicación}

Cabe señalar que este material está enfocado a la generación de geometrías mediante código de programación. Además se enfoca a la \textit{personalización} de GiD, por lo que no es un manual de usuario. Este último se puede encontrar en \textcolor{BlueGiD}{\underline{\url{www.gidhome.com/support/gid-manuals/}}}. En caso de surgir dudas puntuales el \textit{Customization Manual} es muy amplio. Adicionalmente se puede consultar los foros de ayuda de GiD, el link es \textcolor{BlueGiD}{\underline{\url{www.gidhome.com/forum/}}}.

\newpage

\section{Primeros pasos}

¿Qué es lo que hace interesante GiD?. La respuesta es la \textbf{programación}, GiD está escrito para que sea de propósito general, de manera que los usuarios pueden crear sus propios solvers y manipular la información que entra y sale de él. Para explicar lo anterior, se tiene el siguiente diagrama:

\begin{figure}[hbtp!]
	\centering
	\includegraphics[width=0.35\textwidth]{etapasGiD.PNG}
	\caption{Diagrama del proceso que realiza un Problem Type.\label{fig:diagramaProcesos}}
\end{figure}

La manera como se desarrollaban anteriormente los problem types no era tan interactiva con el usuario, impidiendo personalizar la entrada y salida de datos. Desde la \textit{versión 13} de GiD se ha implementado una nueva versión de problem type (basado en la librería CustomLIB) y aunque el sistema ``clásico'' sigue siendo soportado por GiD, esta nueva versión usa un único archivo con extensión \texttt{.spd} (basado en XML) para describir las propiedades generales, materiales, condiciones y unidades. Toda esta información se muestra en una ``vista de árbol'' y los materiales y condiciones son asociados en grupos de entidades los cuales son leídos y procesados mediante el lenguaje de programación \textbf{TCL/Tk} (orientado a objetos) que permitirá crear interfaces gráficas de usuario (GUI) y darle un mejor aspecto a los problem types.

La combinación de TCL/Tk y XML, definirá el rumbo que el usuario le de a su problem type, es por ello que es importante leer y aprender de estas dos herramientas. Como no es el objeto de este material una buena guía para TCL se puede encontrar en: \textcolor{BlueGiD}{\underline{\url{www.tcl.tk/doc/}}\label{sec:manualTCL}}, y para XML en: \textcolor{BlueGiD}{\underline{\url{www.w3schools.com/xml/}}}.

\subsection{El sistema del problem type}

Un problem type es una colección de archivos, los cuales permiten al usuario establecer los parámetros de entrada para un problema computacional, a este proceso también se le conoce como \textit{personalización} en GiD. 

El nuevo sistema para la personalización agrega algunas capacidades adicionales comparado con el sistema clásico:

\begin{itemize}
	\item Aprovecha las características del formato XML y su estructura jerarquizada. Almacena información eficientemente. Los elementos en un documento XML forman una estructura de árbol que ``comienza en la raíz y se ramifica hasta las hojas'' con diferentes relaciones entre los elementos anidados.
	\item Facilita la creación automática de \textit{ventanas estandarizadas} en el árbol de datos (\textit{data tree}) para introducir datos.
	\item Permite acoplar entidades con propiedades idénticas en grupos.
	\item Permite aplicar eficientemente propiedades geométricas y condiciones de contorno en grupos para editar sus propiedades fácilmente.
\end{itemize}

\subsection{Editor de código}

Dada que para trabajar en GiD utilizaremos dos lenguajes (XML y TCL/Tk), se necesita un editor de texto que permita una escritura de código de manera versátil. Existen editores de texto que brindan \textit{soporte} para los diferentes lenguajes de programación es decir, cuando se crea un archivo con extensión \textbf{\texttt{.cpp}} (C++), \textbf{\texttt{.java}} (Java), \textbf{\texttt{.m}} (MATLAB/Octave), el editor detecta las palabras reservadas del lenguaje en cuestión y las resalta con colores, esto permite una mejor visualización del código. Una muy buena opción es \textbf{Notepad++}, un libre editor muy liviano de código fuente que se puede encontrar en:\\ 

\textcolor{BlueGiD}{\underline{\url{www.notepad-plus-plus.org/download/}}}\\

También se puede utilizar \textbf{Visual Studio Code}, el cual brinda una mayor personalización e integración con un sistema CVS. Este se encuentra en:\\

\textcolor{BlueGiD}{\underline{\url{https://code.visualstudio.com/}}}\\

Cabe mencionar que GiD tiene su editor de TCL incluido (\textit{Data}>\textit{Problem type}>\textit{Debugger...}) sin embargo se prefiere usar los editores anteriores gracias a su amplio soporte.

\subsection{Mini-tutorial de XML}

\begin{itemize}
	\item ¿QUÉ ES XML?
		\begin{itemize}
			\item XML significa eXtensible Markup Language.
			\item Es un meta-lenguaje que permite representar información estructurada de modo que esta pueda ser almacenada, transmitida, procesada, visualizada e impresa, por diversos dispositivos a través de un \textit{analizador sintáctico}.
		\end{itemize}
	\item ¿QUÉ NO ES XML?
		\begin{itemize}
			\item No es una versión mejorada de HTML.
			\item No es un lenguaje para hacer páginas Web.
			\item No es difícil.
		\end{itemize}
		\newpage
	\item ¿POR QUÉ XML?
		\begin{itemize}
			\item Es un estándar internacionalmente conocido.
			\item No pertenece a ninguna compañía.
		\end{itemize}
\end{itemize}

Este es un ejemplo de cómo luce un XML. Gracias a su característica de marcado, puede ser interpretado por una computadora y por humanos. La primera línea es de carácter obligatorio ya que define los parámetros de lectura del intérprete.

\lstset{language=XML} 
\begin{lstlisting}[caption={Ejemplo de una clasificación de lenguajes en XML.}]
<?xml version="1.0" encoding="utf-8"?>
<!-- Esto es un comentario -->
<LenguajesProgramacion>
  <lenguaje tipo="poo">
    <nombre>TCL Tk</nombre> 
    <siglas>Tool Command Language Tool Kit</siglas>   
  </lenguaje>
  
  <lenguaje tipo="marcado">
    <nombre>XML</nombre>
    <siglas>eXtensible Markup Language</siglas>
  </lenguaje>
</LenguajesProgramacion>
\end{lstlisting}

\subsection{Mini-tutorial de TCL}

A continuación se ejemplifican tareas básicas de TCL.

\lstset{language=tcl} 

\begin{lstlisting}[caption={Asignar valor a una variable.}]
set entero 1; # Valor entero
set flot 1.0; # Valor flotante 
\end{lstlisting}

\begin{lstlisting}[caption={Asignar valor de una variable a otra.}]
set entero1 "Hola mundo!"; # Uso de cadenas de texto
set entero2 $entero1; # Asignar valor a variable
\end{lstlisting}

\begin{lstlisting}[caption={Operaciones matemáticas.}]
set tres 3.0
set suma [expr 1.0+2.0+$tres]; # Sumar numeros con variables
\end{lstlisting}

\begin{lstlisting}[caption={Crear funciones o procedimientos (\textbf{\texttt{proc}}).}]
proc FuncionSuma { arg1 arg2 } {
	return [expr $arg1+$arg2]; # Regresa suma de dos numeros
}
proc ProgramaPrincipal { } {
	set num1 37.0; # Valor flotante 
	set num2 45.65; # Valor flotante 
	set resultado [FuncionSuma $num1 $num2]; # Se utilizan corchetes para invocar otros programas
	puts $resultado; # Imprimir en pantalla el resultado
}
\end{lstlisting}

\subsection{Estructura del problem type}

Un problem type se define creando una carpeta cuyo nombre será definido por el usuario, seguido de la extensión ''\textbf{.gid}´´ y en esta se colocarán una serie de archivos que tendrán una estructura específica. \textbf{A modo de ejemplo en este manual se creará uno llamado \texttt{EjemploPT.gid}}.

\textcolor{red}{\textbf{¡IMPORTANTE!}:}El nombre de la carpeta deberá ser respetado, no se permitirán modificaciones como intercambiar mayúsculas con minúsculas, agregar texto o números, etc. Esto podría causar un conflicto en los nombres.

La carpeta del problem type creada se deberá ubicar en el directorio \textbf{problemtypes} de la distribución \textit{GiD} que se tenga instalado en la computadora, por ejemplo en caso que sea la versión \texttt{13.x} en Windows, se debe colocar la carpeta \textbf{\texttt{EjemploPT.gid}} en la dirección:

\begin{small}
\begin{verbatim}
C:\Archivos de programa\GiD\GiD 13.x\problemtypes
\end{verbatim}
\end{small}

\textcolor{purple}{\textbf{TIP}:} Como se estará modificando el contenido de una carpeta contenida \textit{Archivos de programa} (suponiendo que se trabaja en Windows), el editor solicitará permisos de \textit{administrador} cada que se modifiquen los archivos. Esto será demasiadas veces y puede ser poco eficiente el otorgar permisos. Para ello se recomienda colocar la carpeta del problem type en una ubicación que no sea \textit{Archivos de programa} (Escritorio, Documentos, etc.), copiar esta carpeta y pegar el \textit{acceso directo} (Click derecho>Pegar acceso directo) en el directorio de los problem types, editando el nombre para que no aparezca ``\texttt{EjemploPT.gid - Acceso directo}'' y tenga solo el nombre ``\texttt{EjemploPT.gid}''.

Una vez colocada la carpeta en la dirección anterior, con ayuda del editor de texto se crean y colocan en ella los siguientes archivos:

\begin{table}[hbtp!]
	\begin{tabular}{l m{4.5cm}}
		\rowcolor{BlueGiD!60} Nombre del archivo & Descripción\\
		\rowcolor{BlueGiD!20} EjemploPT.spd & Archivo de configuración principal del árbol de datos, basado en \textbf{XML}.\\
		EjemploPT.tcl & Archivo \textbf{TCL} principal, inicialización.\\
		\rowcolor{BlueGiD!20} EjemploPT.cnd & Definición de condiciones. No debería modificarlo el usuario final.\\
		EjemploPT.xml & Define la configuración principal del problemtype.\\
	\end{tabular}
	\caption{Archivos contenidos en \textbf{\texttt{EjemploPT.gid}} para inicializar el problem type.\label{tab:estructuraArchivos}}
\end{table}

El directorio del problem type debe quedar así:

\begin{verbatim}
	EjemploPT.gid\
	EjemploPT.gid\EjemploPT.spd
	EjemploPT.gid\EjemploPT.tcl
	EjemploPT.gid\EjemploPT.cnd
	EjemploPT.gid\EjemploPT.xml
\end{verbatim}

Posteriormente abrimos \textit{GiD} y en el menú \textit{Data}>\textit{Problem type} se debe encontrar el que recién se creó (\textbf{\texttt{EjemploPT}}) sin importar que no se ha escrito nada en estos archivos. Si al seleccionarlo no se ha producido ningún error, \textbf{los archivos se han cargado satisfactoriamente}.

\section{Estructura de los archivos}

En esta sección hablaré de la estructura y parámetros de configuración adecuados a los archivos que se describieron en el Cuadro~\ref{tab:estructuraArchivos}.

\subsection{EjemploPT.cnd}

\textcolor{red}{\textbf{NOTA}:}Este material no se enfocará a la definición de este archivo, si bien es necesario para establecer las condiciones de contorno, no es necesario para abrir un problem type, por lo tanto \textcolor{blue}{\textbf{en el ejemplo de este material NO se incluye el arhivo \texttt{EjemploPT.cnd}}} debido a que \textbf{este material está enfocado a generación de geometrías}. Aquí se detallará la estructura básica, de requerirse a detalle más opciones, consultar el \textit{Customization Manual}.

Se escribe en un archivo \texttt{.cnd} toda la información que puede ser aplicada a las diferentes entidades (puntos, líneas, superficies y volúmenes). Este tipo de información incluye por ejemplo, las restricciones de desplazamiento y cargas aplicadas en un problema estructural o las temperaturas iniciales y prescritas en un análisis térmico.

Una característica importante de las condiciones es que se debe seleccionar a qué tipo de entidad será aplicada, por ejemplo: sobre puntos (\textit{over points}), sobre líneas (\textit{over lines}), sobre superficies (\textit{over surfaces}), sobre volúmenes (\textit{over volumes}), sobre capas (\textit{over layers}) o sobre grupos (\textit{over groups})y sobre qué tipo de entidad de la malla serán transmitidas: sobre nodos (\textit{over nodes}), sobre la cara de los elementos (\textit{over face elements}) o sobre cuerpos de elementos (\textit{over body elements}).

\begin{itemize}
\item \textbf{over nodes}: Significa que la condición será transferida a los nodos contenidos en la entidad geométrica donde la condición es asignada.
\item \textbf{over face elements ?multiple?}: Si esta condición es aplicada una línea que es el límite de una superficie o a una superficie que es límite de un volumen, esta condición es transferida a los elementos superiores, marcando la cara afectada. Si es declarada como \textbf{múltiple}, puede ser transferida a más de una cara de elemento (si existe más de una). Por default es considerada como \textbf{single}, y solo una cara del elemento será marcada.
\item \textbf{over body elements}: Si esta condición es aplicada a líneas, será transferida a los elementos línea. Si se asigna a superficies, será trasferida a elementos superficie. Y como se puede intuir si se aplica para volúmenes, será transferida a elementos volumen.
\end{itemize}

El formato del archivo es como sigue:

\lstset{language={}}
\begin{lstlisting}
CONDITION: nombre_condicion
CONDTYPE: 'over points', 'over lines', 'over surfaces', 'over volumes', 'over layers', 'over groups'
CONDMESHTYPE: 'over nodes', 'over face elements','over face elements multiple', 'over body elements'
GROUPALLOW: points lines surfaces volumes nodes elements faces
QUESTION: field_name['#CB#'(...,valor_opcional_i,...)]
VALUE: default_field_value['#WIDTH#'(longitud_de_entrada_opcional)]
...
QUESTION: field_name['#CB#'(...,valor_opcional_i,...)]
VALUE: default_field_value['#WIDTH#'(longitud_de_entrada_opcional)]
END CONDITION

CONDITION: condition_name
...
END CONDITION
\end{lstlisting}

\textbf{Nota}: CONDTYPE y CONDMESHTYPE son obligatorios, y solo se debe establecer uno de estos dos.\\
\textbf{Nota}: GROUPALLOW es válido solo para las condiciones ``over groups'', es un campo opcional para restringir categorías permitidas de entidades del grupo listado (si este campo se omite entonces todas las entidades están permitidas). Puede establecerse una lista de múltiples tipos.\\
\textbf{Nota}: \#CB\# significa Combo Box, el cual es un elemento que muestra una lista desplegable.\\
\textbf{Nota}: \#WIDTH\# significa el tamaño de la entrada usado por el usuario para ingresar el valor de la condición. Especifica un valor entero indicando el ancho deseado de la ventana de entrada.\\

\subsection{EjemploPT.xml}\label{sec:codigoXML}

El archivo de configuración inicial XML, contiene datos generales del programa. Este archivo generalmente sólo se configura una sola vez porque los datos sólo son informativos.

Aunque el archivo es muy corto la información es esencial, no se debe omitir ninguna de estas etiquetas ni modificar los identificadores. Existen más etiquetas para darle más información a GiD sobre nuestro problem type, pero las siguientes son de uso \textbf{obligatorio}.

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<Infoproblemtype version="1.0">
  <Program>
    <Name>EjemploPT</Name>
    <Version>1.0</Version>   
    <MinimumGiDVersion>12.1.11d</MinimumGiDVersion>
    <CustomLibAutomatic>1</CustomLibAutomatic>
 </Program>
</Infoproblemtype>
\end{lstlisting}

\textcolor{blue}{NOTA:} La \textit{etiqueta} \texttt{\textcolor{blue}{CustomLibAutomatic}} debe tener el valor de \texttt{\textcolor{blue}{1}} (uno). Este activa el uso de la librería \textit{CustomLib} que permite acceder a funciones del nuevo sistema de problem types.
\newpage
\subsection{EjemploPT\_default.spd}

Este archivo define la configuración principal del \textit{Árbol de datos} (\textit{Data tree}, en inglés), cuyo fin es estructurar las condiciones, materiales y otros datos del modelo computacional. Está basado en XML.

En XML podemos crear \textit{campos o etiquetas} con cualquier nombre, para almacenar diferentes datos estos identificadores. En la programación de problem types, los nombres de estos campos o etiquetas ya se encuentran reservados y son leídos e interpretados por GiD para que pueda crear elementos visuales (listas desplegables, menú estructurado, etc.). En la documentación de GiD se describe la estructura adecuada para estas \textit{etiquetas}.

Para ramificar el árbol de datos, estas etiquetas pueden anidarse para contener objetos dentro de otros. La estructura que se le dará al ejemplo de este material se verá más adelante pero aquí se comienza a ejemplificar. En este manual solo se describen algunas de ellas:

\subsubsection{$<$PT\_data$>$}

\vspace{0.20cm}
\begin{center}
	\texttt{$<$PT\_data$>$}
\end{center}
\vspace{0.20cm}

Es \textbf{etiqueta principal y obligatoria} del archivo \texttt{.spd}. Dentro de esta se almacenará la estructura del problem type también contiene el número de versión. Los caracteres \texttt{PT} deben ser remplazados por el nombre del problem type. A su vez este elemento/etiqueta es la \textbf{raíz} (root) del archivo \texttt{EjemploPT\_default.spd} (se retomará más adelante).

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{version} - Número de versión interno.
\vspace{0.15cm}

Como el problem type que crearemos se llama \texttt{EjemploPT}, la etiqueta quedaría:

\lstset{language=XML} 
\begin{lstlisting}[caption={Etiqueta principal que contiene la estructura del PT.}]
<?xml version="1.0" encoding="utf-8"?>

<EjemploPT_data version='1.0'>
	...
</EjemploPT_data>
\end{lstlisting}

\subsubsection{$<$container$>$}

\vspace{0.20cm}
\begin{center}
	\texttt{$<$container$>$}
\end{center}
\vspace{0.20cm}


Es la forma más simple de agrupar datos y mejorar su visualización. En la ventana resultante, además de las entradas, se encontrarán los siguientes botones:

\begin{figure}[hbtp!]
	\centering
	\includegraphics[scale=1]{container.png}
\end{figure}

Puede contener o anidarse en esta etiqueta los siguientes campos: \texttt{<value>}, \texttt{<container>}, \texttt{<condition>}, \texttt{<functions>} y \texttt{<dependencies>} (en este manual no se definirán todas las etiquetas).

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{n} - Nombre usado para referenciar el campo, especialmente cuando se escriben los arhivos \texttt{.dat} y \texttt{.tcl}.\\
	\textbf{pn} - Etiqueta que será visualizada por el usuario.\\
	\textbf{icon} - Permite poner una imagen en formato \texttt{.png} en el \textit{data tree}- La imagen debe ser guardada dentro de la carpeta llamada \texttt{images} del problem type.\\
	\textbf{help} - Despliega una ventana \textit{pop-up} con información de ayuda relacionada a la tarea que el usuario desea realizar. Aparece a los pocos segundos de posicionar el cursor en el container.\\
	\textbf{actualize\_tree} - Actualiza la información que contiene en todo el \textit{data tree} y automáticamente actualiza los datos mostrados en la interfaz del usuario. Es un valor booleano de 1 o 0 indicado si está activada o desactivada esta función.
\vspace{0.15cm}

\textit{Uso}:
\vspace{0.15cm}

\lstset{language=XML} 
\begin{lstlisting}[caption={Ejemplo de <container> anidados.}]
<?xml version="1.0" encoding="utf-8"?>

<EjemploPT_data version="1.0">
	<container n="contenedor1" pn="Container 1" help="Esto es un ejemplo." actualize_tree="1">
		<container n="contenedor2" pn="Container 2" help="Containers anidados" actualize_tree="1">
			<value n="valor" pn="Valor" v="1.0"/>
		</container>
	</container>
</EjemploPT_data>
\end{lstlisting}

\subsubsection{$<$value$>$}
\label{subsubsec:value}
\vspace{0.20cm}
\begin{center}
	\texttt{$<$value$>$}
\end{center}
\vspace{0.20cm}

Es el campo principal para almacenar datos. Este campo permite definir una \textit{caja de entrada} en la ventana.

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{n} - Nombre usado para referenciar el campo, especialmente cuando se escriben los arhivos \texttt{.dat} y \texttt{.tcl}.\\
	\textbf{pn} - Etiqueta que será visualizada por el usuario.\\
	\textbf{v} - El valor o valor por defecto del campo.\\
	\textbf{values} - Lista de cadenas de caracteres separados por comas. Crea una lista desplegable. Por ejemplo: \texttt{values="Poisson,Young"}.\\
	\textbf{actualize\_tree} - Actualiza la información que contiene en todo el \textit{data tree}.
\vspace{0.15cm}

\textit{Uso}:
\vspace{0.15cm}

\lstset{language=XML} 
\begin{lstlisting}[caption={Creación de <value> para almacenar datos.}]
<?xml version="1.0" encoding="utf-8"?>
<container n="caja" pn="Caja">
  <value n="base" pn="Base:" v="5.00"/>
  <value n="altura" pn="Altura:" v="6.00"/>
</container>
\end{lstlisting}

\textit{Anidar} las etiquetas \texttt{$<$value$>$} en \texttt{$<$container$>$}, como el ejemplo anterior produce lo siguiente:

\begin{figure}[hbtp!]
	\centering
	\includegraphics[scale=.8]{value_field.png}
\end{figure}


\subsubsection{$<$blockdata$>$}

\vspace{0.20cm}
\begin{center}
	\texttt{$<$blockdata$>$}
\end{center}
\vspace{0.20cm}

Representa un arreglo de propiedades con algún tipo de relación. Un campo ``\texttt{blockdata}'' puede copiarse a sí mismo para duplicar y crear diferentes arreglos. Esta etiqueta es comúnmente utilizada para uso como \textit{base de datos} del problem type.

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{n} - Nombre usado para referenciar el campo, especialmente cuando se escriben los arhivos \texttt{.dat} y \texttt{.tcl}.\\
	\textbf{name} - Atributo que será visualizado por el usuario.\\
	\textbf{icon} - Permite poner una imagen en formato .png en el árbol de datos. La imagen debe ser almacenada dentro de la carpeta \texttt{images} del directorio del problem type (ejemplo: \texttt{EjemploPT.gid\textbackslash images\textbackslash icono.png}).\\
\vspace{0.15cm}

\textit{Uso}:
\vspace{0.15cm}

\lstset{language=XML} 
\begin{lstlisting}[caption={Uso de <blockdata> para agrupar otros elementos.}]
<?xml version="1.0" encoding="utf-8"?>
<container n="basedatos" pn="Base de datos">
	<blockdata n="libro" name="Aspectos fundamentales del concreto reforzado">
		<value n='id' pn='ID' v='50.0 GON E1'/>
		<value n='isbn' pn='ISBN' v='968-4981-7'/>
	</blockdata>
	<blockdata n="libro" name="Calculo de estructuras por el metodo de los elementos finitos">
		<value n='id' pn='ID' v='30.40 ONA E1'/>
		<value n='isbn' pn='ISBN' v='84-87867-00-6'/>
	</blockdata>
</container>
\end{lstlisting}


\subsubsection{$<$procs$>$ y $<$proc$>$} \label{sec:calculararea}

\textcolor{red}{\textbf{¡IMPORTANTE!}:} Antes de explicar las etiquetas \texttt{$<$procs$>$} y \texttt{$<$proc$>$} se debe describir el uso de las \textbf{secciones \texttt{CDATA}}. En un documento XML, una sección \texttt{CDATA} (del inglés, \textbf{character data}) es aquella perteneciente a un documento que es marcado para que el \textit{analizador sintáctico} lo interprete como una cadena de caracteres y no como contenido etiquetado. No hay diferencia semántica entre una cadena de caracteres dentro de una sección \texttt{CDATA} y la sintaxis usual en la que ``$<$'', ``$>$'' y ``$\&$'' estarían representados por ``\texttt{\&lt}'', ``\texttt{\&gt}'' y ``\texttt{\&amp}'' respectivamente.

Una sección \texttt{CDATA} empieza con la siguiente secuencia:

\begin{flushleft}
\begin{verbatim}
<![CDATA[
\end{verbatim}
\end{flushleft}

y termina con la primera ocurrencia de la secuencia:

\begin{flushleft}
\begin{verbatim}
]]>
\end{verbatim}
\end{flushleft}

los caracteres encapsulados dentro de estas dos secuencias son interpretados como caracteres, no como etiquetas o como referencia a entidades.

\lstset{language=XML} 
\begin{lstlisting}
<nombre>Luis Guillermo</nombre>
\end{lstlisting}

El texto contenido dentro de las etiquetas \textbf{\texttt{nombre}} es interpretado como elemento XML. Sin embargo si se escribe de esta manera:


\begin{verbatim}
<![CDATA[<nombre>Luis Guillermo</nombre>]]>
\end{verbatim}

Es interpretado como si se hubiera escrito así:

\begin{verbatim}
&lt;nombre&gt;Luis Guillermo&lt;/nombre&gt;
\end{verbatim}

¿Qué finalidad tiene esto?. Lo que interesa aquí, es que el texto contenido en una sección \texttt{CDATA} no sea leído por XML y sea interpretado por TCL. ¿Qué es eso que debe interpretar TCL y no XML?, TCL debe leer funciones de TCL. ¿Y cómo se le indica a TCL qué es lo que debe interpretar él y no XML?, mediante las etiquetas \texttt{$<$procs$>$} y \texttt{$<$proc$>$}. Todo aquello contenido dentro de estas últimas será leído por TCL.

\vspace{0.20cm}
\begin{center}
	\begin{tabular}{rcl}
		\texttt{$<$procs$>$} &y&\texttt{$<$proc$>$}\\
	\end{tabular}
\end{center}
\vspace{0.20cm}

La etiqueta \texttt{$<$procs$>$} \textbf{agrupa las declaraciones de los procedimientos} o funciones (\texttt{procs}) de TCL que se ejecutarán desde el árbol de datos. En cambio con la etiqueta \texttt{$<$proc$>$} \textbf{se declaran}.

La etiqueta \texttt{$<$procs$>$} no lleva ningún atributo. La etiqueta \texttt{$<$proc$>$} lleva los siguientes atributos:

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{n} - Nombre usado para referenciar el campo, especialmente cuando se escriben los arhivos \texttt{.dat} y \texttt{.tcl}.\\
	\textbf{args} - ``args'', el cual indica al intérprete de GiD que se introducirá información acerca de los nodos.\\
\vspace{0.15cm}

\textit{Uso}:
\vspace{0.15cm}

\lstset{language=XML} 
\begin{lstlisting}[caption={Uso de <procs> y <proc> para invocar rutinas de TCL en XML. Nótese el uso de la función del namespace EjemploPT}]
<?xml version="1.0" encoding="utf-8"?>
<container n="caja" pn="Area rectangulo" actualize_tree="1">
  <value n="base" pn="Base" v="5.00" actualize_tree="1"/>
  <value n="altura" pn="Altura:" v="6.00"actualize_tree="1"/>
  <value n="area" pn="Area" v="[EjemploPT::CalcularArea]" actualize_tree="1"/>
</container>
<procs>
  <proc n="EjemploPT::CalcularArea" args="args">
    <![CDATA[
      EjemploPT::CalcularArea $domNode $args
    ]]>
  </proc>
</procs>
\end{lstlisting}

Así, TCL podrá leer y ejecutar una función llamada \texttt{CalcularArea}, que será definida en la sección que sigue con ayuda de las funciones \texttt{CustomLib}. Nótese que se deben incluir los argumentos \textcolor{blue}{\texttt{domNode args}} a la función para indicarle a TCL que se leerá desde un archivo XML. No olvidar incluirlos en la definición de la función. 


\subsection{EjemploPT.tcl}

A diferencia de los archivos anteriores, que definen la estructura del problem type, el archivo \texttt{.tcl} se encarga de la lógica de esa estructura. El lenguaje de este archivo, como su extensión lo indica es \textbf{TCL/TK puro}. Toda la documentación acerca del lenguaje TCL se encuentra disponible en el enlace que se mostró en la Sección~\ref{sec:manualTCL}.

\subsubsection{Eventos} \label{sec:eventosGiD}

Como vimos en XML, hay etiquetas con un nombre específico que GiD interpreta para realizar diferentes acciones. Lo mismo sucede en el archivo \texttt{.tcl} pero con los \textbf{eventos}. Los \textit{eventos} en la programación, son rutinas de código que se ejecutan cuando una acción se realiza durante el programa, mismas que el usuario invoca. Por ejemplo, cuando el usuario abre GiD, suceden eventos para cargar el área de dibujo, abrir la barra de herramientas, cargar el idioma y las preferencias del usuario, etc. Cuando se crea un problem type ocurre lo mismo a diferencia de que estas funciones ya se encuentran definidas por GiD y listas para editarse.

La guía del uso de estas funciones se encuentran en el \textit{Customization Manual} contenido en la referencia de este documento, pero aquí se mencionan solo dos, el evento \textcolor{blue}{\texttt{InitGIDProject}} y \textcolor{blue}{\texttt{SaveGIDProject}}:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Evento que se ejecuta al iniciar el problemtype.}]
proc InitGIDProject { dir } {

}
\end{lstlisting}

\textit{Descripción}: Será llamada cuando se seleccione el problem type. Recibe el argumento \texttt{dir}, el cual es la ruta absoluta del directorio del problem type. Es muy útil guardar \texttt{dir} para posteriormente  acceder a otros archivos dentro del directorio como lo haremos más adelante.

\begin{lstlisting}[caption={Evento que se ejecuta al guardar un proyecto en GiD durante la ejecución de un problem type.}]
proc SaveGIDProject { filespd } {

}
\end{lstlisting}

\textit{Descripción}: Será llamada cuando el proyecto actual sea guardado en el disco duro. Recibe el argumento \texttt{filespd}, el cual es la ruta del archivo guardado, pero con extensión \texttt{.spd}.

\subsubsection{Función \texttt{GiD\_Process}} \label{sec:GiDProcess}

\vspace{0.20cm}
\begin{center}
	\textbf{\texttt{GiD\_Process}} \texttt{\textit{comando\_1 comando\_2 comando\_3 ... comando\_n}}
\end{center}
\vspace{0.20cm}


La instrucción \textbf{GiD\_Process} es una función de TCL usado para ejecutar comandos de GiD. Es una simple pero poderosa función. Los comandos tienen la misma forma que aquellos introducidos en la línea de comando de GiD. Se debe introducir la misma secuencia como si se hiciera interactivamente, incluyendo las \textbf{secuencias de escape} y seleccionando los menús y operaciones usadas.

Se puede obtener los comandos exactos que GiD necesita de dos maneras:

\begin{enumerate}
	\item Activando el menú ``\textbf{Right buttons}'' (\textit{Utilities}>\textit{Tools}>\textit{Toolbars}>Marcar \textit{Inside} en \textit{Right buttons}).	
	\begin{figure}[hbtp!]
	\centering
	\includegraphics[scale=.8]{rightbuttons.PNG}
	\caption{Secuencia de comandos al usar \textit{Right buttons}.\label{fig:rightbuttons}}
\end{figure}
	\item Revisar la ventana \textbf{Undo} una vez realizada una tarea (\texttt{CTRL+z}) y así revisar el procedimiento. En el ejemplo de la Figura~\ref{fig:undo} se muestran las secuencias generadas al dibujar una línea que inicie en las coordenadas [0.0,0.0] y termine en [10.0,10.0].
	\begin{figure}[hbtp!]
	\centering
	\begin{minipage}[t]{0.2\textwidth}
	\includegraphics[width=\textwidth]{undowin.PNG}
	\end{minipage}
	\begin{minipage}[t]{0.16\textwidth}
	\includegraphics[width=\textwidth]{undoline.PNG}
	\end{minipage}
	\caption{Secuencia de comandos al usar \textit{Right buttons}.\label{fig:undo}}
\end{figure}
	
\end{enumerate}
\newpage
Es común utilizar la instrucción \textbf{Mescape} seguido de usar \textbf{GiD\_Process}, este comando es un múltiple comando ``escape'' para así garantizar salir de cualquier menú. Por lo tanto para el ejemplo de la Figura~\ref{fig:undo} dibujar la misma línea en TCL se haría de la siguiente manera:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Dibujar una línea en código en código.}]
GiD_Process Mescape Geometry Create Line 0.0,0.0 10.0,10.0 escape
\end{lstlisting}


\subsubsection{Programación en TCL}

En esta sección se hablará de TCL, las funciones \texttt{namespace}. Un \texttt{namespace} es un área de trabajo que permite particionar diferentes comandos y variables de otras áreas de trabajo. Esto será útil para separar las funciones que nosotros hemos de crear con las que ya están definidas por GiD y evitar la \textit{colisión de nombres}. Una vez creada el área de trabajo, podremos almacenar en esta todas nuestras variables y funciones propias del \texttt{namespace}.

Para crear un \texttt{namespace} se utiliza el siguiente comando:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Crear un namespace en TCL.}]
namespace eval path {

}
\end{lstlisting}

Donde \texttt{path} será la ruta (o identificador) del área de trabajo, en este caso ponermos el \textbf{nombre del problem type}. Dentro de las llaves usualmente se declaran todas las variables globales que estarán durante todo el problem type. Por ejemplo, para crear un \texttt{namespace} para \texttt{EjemploPT} escribiremos en el archivo \texttt{.tcl} lo siguiente:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Declarar una variable propia del namespace.}]
namespace eval EjemploPT {
	variable radio
}
\end{lstlisting}

Lo que hace el código anterior es crear una variable global llamada \texttt{radio} en el namespace \texttt{EjemploPT} para que pueda ser accesada en otras rutinas propias del namespace.

En el siguiente ejemplo se crea una función (o proc) llamada \textcolor{blue}{\texttt{CalcularAreaCirculo}} en el \texttt{namespace} \texttt{EjemploPT}. Llama la variable global \texttt{radio} y almacena el valor de \texttt{5.00} y la función regresa el valor del área de un círculo:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Función que calcula el área de un círculo.}]
proc EjemploPT::CalcularAreaCirculo { } {
	variable radio	
	set radio 5.00
	return [expr $radio*$radio*3.14159265359]
}
\end{lstlisting}

\subsubsection{Parser: Manipular XML desde TCL}

Hasta ahora sabemos cómo crear los métodos de entrada en el problem type (etiquetas \texttt{<containter>}, \texttt{<value>}, etc.) pero no hemos visto cómo acceder a ellas. Para ello se utiliza una herramienta común entre muchos lenguajes de programación llamada \textbf{Parser}.

Un \textbf{analizador sintáctico} (o \textit{parser} en inglés) es un programa informático que analiza una cadena de símbolos llamada \textit{XPath} de acuerdo a las reglas de una gramática formal. Usualmente hace parte de un compilador, en cuyo caso transforma una entrada en un árbol sintáctico de derivación. El \textbf{analizador sintáctico de TCL} se llama \textbf{tdom}.

Estos símbolos son las referencias a los elementos de un archivo XML con los cuales podremos manipular los elementos visuales, producto de las etiquetas \texttt{<containter>}, \texttt{<value>}, etc. La convención de estas referencias se llama \textbf{Modelo de Objetos del Documento}, \textbf{DOM} (\textit{Document Object Model} en inglés). El DOM es esencialmente una convención que proporciona un estándar de objetos para representar documentos HTML, XHTML y XML.

A manera de resumen, los pasos para leer y/o modificar el archivo XML (\texttt{EjemploPT\_default.spd}) desde TCL son los siguientes:

\begin{enumerate}
	\item Obtener el parser para TCL. Esto se hace escribiendo la rutina:
	\begin{lstlisting}[caption={Instrucción para obtener el parser para TCL.}]
	package require tdom; # Maneja el DOM
	\end{lstlisting}
	\item Obtener el elemento principal del archivo XML (en nuestro caso es el elemento \texttt{<EjemploPT\_data>}, el cual es la \textbf{raíz} (root) del las etiquetas) mediante DOM.
	\item Acceder mediante una ruta XPath a elemento de esa raíz (\texttt{<containter>}, \texttt{<value>}, etc). La gramática del XPath es muy sencilla por lo que no se cubrirá en este material. La referencia oficial de Xpath se encuentra en \textcolor{BlueGiD}{\underline{\url{www.w3schools.com/xml/xpath_intro.asp}}}.
	\item Una vez seleccionado el elemento, se accede a su valor o atributo.
\end{enumerate}

Para el ejemplo de la Sección~\ref{sec:calculararea} se muestra una modificación a la función \textcolor{blue}{\texttt{CalcularArea}} (invocada desde el árbol de datos con la etiqueta \texttt{<proc>}) en la que se recupera el valor de la \texttt{base} y \texttt{altura} desde \texttt{<value>} y el resultado se imprime en otro \texttt{<value>} (Nótese que se incluyen los argumentos \textcolor{blue}{\texttt{domNode args}}):

\newpage

\lstset{language=tcl} 
\begin{lstlisting}[caption={Cálculo del área obteniendo los valores desde el archivo \texttt{.spd} usando las funciones de \texttt{CustomLib}.}]
proc CalcularArea { domNode args } {
	set rootXML [customlib::GetBaseRoot]
	set base [get_domnode_attribute [$rootXML selectNodes "\container\[@n='caja'\]/value\[@n='base'\]"] v]
	set altura [get_domnode_attribute [$rootXML selectNodes "\container\[@n='caja'\]/value\[@n='altura'\]"] v]
	return [expr $base*$altura]
}
\end{lstlisting} 

\textbf{customlib::GetBaseRoot}: Es una rutina incluída en \textit{CustomLib} para obtener fácilmente la raíz de un documento XML que por defecto es \texttt{EjemploPT\_default.spd}. Por lo que la raíz será \texttt{<EjemploPT\_data>}.\\
\textbf{\textit{raiz} selectNodes \textit{xpath}}: Donde \textbf{selectNodes} es una instrucción propia del parser (tdom) para seleccionar un nodo de \textit{raiz} mediante una \textit{xpath}. \textit{root} puede ser también un nodo que contenga a otros.\\
\textbf{get\_domnode\_attribute \textit{nodo} \textit{atributo}}: Función  de \textit{CustomLib} para obtener un \textit{atributo} especificado de un \textit{nodo}. En este caso se obtiene el atributo ``\texttt{\textbf{v}}'' que equivale a 5.00.

Los conceptos vistos se aplicarán en el ejemplo de este material.

\section{Problem type: EjemploPT.gid}

Orientaré esta manual a solo un ejemplo en el que se abarque el uso de las estructuras antes vistas. Se trabajará únicamente con los archivos \texttt{.tcl} y \texttt{.spd} ya que el archivo \texttt{.xml} sólo es de configuración y se puede ``reutilizar'', por ende consideraré que los archivos \texttt{.tcl} y \texttt{.spd} se encuentran en blanco. Primero plantearé las \textit{Consideraciones generales} que debe cubrir el problema. Posteriormente la programación del problem type. 

\subsection{Consideraciones generales del ejemplo} \label{sec:consideraciones}

Se pretende crear un problem type en el que se pueda \textbf{dibujar la geometría de un conjunto de secciones de trabes AASHTO} de forma \textbf{paramétrica}, seleccionando el tipo de trabe mediante \textit{listas desplegables} en el árbol de datos. La geometría de la sección transversal de las trabes es:

% REFERENCIA DE LAS MEDIDAS
\begin{figure}[hbt!]
	\centering
	\includegraphics[width=0.48\textwidth]{sectrans_trabes.PNG}
	\caption{Sección transversal de trabes AASHTO.\label{fig:sectrans_trabes}}
\end{figure}

Con sus respectivas medidas descritas en el Cuadro~\ref{tab:medidasAASHTO}.

\begin{table}[hbtp!]
\centering
	\begin{tabular}{*{7}{c}}
		\rowcolor{BlueGiD!60} Tipo&D1&D2&D3&D4&D5&D6\\
		\rowcolor{BlueGiD!20} I&71&10&0&7.6&13&13\\
		II&91&15&0&7.6&15&15\\
		\rowcolor{BlueGiD!20}III&114&18&0&14&19&18\\
		IV&137&20&0&15&23&20\\
		\rowcolor{BlueGiD!20}V&160&13&7.6&10&25&20\\
		VI&183&13&7.6&10&25&20\\
	\end{tabular}
	\vspace{0.2cm}
	\begin{tabular}{*{7}{c}}
		\rowcolor{BlueGiD!60} Tipo&B1&B2&B3&B4&B5&B6\\
		\rowcolor{BlueGiD!20} I&30&41&15&7.6&0&13\\
		II&30&46&15&7.6&0&15\\
		\rowcolor{BlueGiD!20}III&41&56&18&11&0&19\\
		IV&51&66&20&15&0&23\\
		\rowcolor{BlueGiD!20}V&107&71&20&10&33&25\\
		VI&107&71&20&10&33&25\\
	\end{tabular}
	\caption{Medidas de las secciones transversales para las trabes AASHTO (en pulgadas, \textit{in}.\label{tab:medidasAASHTO})}
\end{table}

\subsection{Estructura de \texttt{EjemploPT.gid}}
Lo que se necesita plantear inicialmente es la estructura del árbol de datos. Esta podría sintetizarse en la Figura~\ref{fig:estructura_spd}.

\begin{figure}[hbtp!]
	\centering
	\includegraphics[width=0.45\textwidth]{estructura_spd.PNG}
	\caption{Estructura del archivo SPD de \texttt{EjemploPT.gid}.\label{fig:estructura_spd}}
\end{figure}

A partir de la etiqueta/raíz del problem type \texttt{$<$EjemploPT\_data$>$} se crea un contenedor (\texttt{$<$container$>$}) que muestre un cuadro de valores (etiqueta \texttt{$<$value$>$}), este desplegará una lista con las etiquetas ``Tipo I'', ``Tipo II'', etc. Las propiedades geométricas de dichos secciones serán agrupadas (uso de \texttt{$<$blockdata$>$}), mismas que fungirán como \textit{base de datos} del problem type.

\subsection{Pasos a seguir}

Organizando las consideraciones generales tenemos los pasos:

\begin{enumerate}
	\item Definir los datos de información del problem type en el archivo \texttt{.xml} (Reutilizado de la Sección~\ref{sec:codigoXML}).
	\item Escribir en el archivo \texttt{.spd} la estructura del árbol de datos tal y como se muestra en la Figura~\ref{fig:estructura_spd}.
	\item Escribir las rutinas necesarias en el archivo \texttt{.tcl} para cargar el \textit{árbol de datos} e inicializar el \texttt{namespace} del problem type.
	\item Crear el catálogo de \texttt{blockdata} que guarde las propiedades geométricas de las trabes (del Cuadro~\ref{tab:medidasAASHTO}) en un archivo XML (ver Anexo~\ref{app:catalogo}). Se puede guardar en el mismo archivo \texttt{.spd} pero aquí lo haré en un archivo separado para mantener una buena práctica de programación.
	\item Hacer una función en TCL que devuelva la lista de los tipos de trabes y vincularla al archivo \texttt{.spd} mediante las etiquetas \texttt{$<$procs$>$}.
	\item Programar un procedimiento en el archivo \texttt{.tcl} que mediante el tipo de trabe seleccionado en el punto anterior, busque y obtenga las propiedades geométricas almacenadas en el \texttt{blockdata} y las guarde variables.
	\item Una vez almacenadas los datos de la geometría, programar el procedimiento en el archivo \texttt{.tcl} para dibujar las trabes de forma paramétrica.
\end{enumerate}

\subsection{Programando el código}

\subsubsection{Archivo \texttt{.spd}}

Escrito el archivo de datos de información del problem type (\texttt{.xml}) se escribe en el archivo \texttt{.spd} en blanco las siguientes líneas de código. El contenido \texttt{CDATA} contiene la llamada de una función que crearemos más adelante llamada \textcolor{blue}{\texttt{EjemploPT::ListaTrabes}}.

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>

<EjemploPT_data version='1.0'>
	<container n="tipoTrabe" pn="Tipo de trabe AASHTO" actualize_tree="1">
		<value n="tipo" pn="Tipo" v="Tipo I" values="[ListaTrabes]" actualize_tree="1"/>
  	</container>
  	<procs>
    	<proc n='ListaTrabes' args='args'>
      	<![CDATA[
        	EjemploPT::ListaTrabes $domNode $args
      	]]>
    	</proc>
  	</procs>
</EjemploPT_data>
\end{lstlisting}

Esto creará una estructura como se deseaba en el la Figura~\ref{fig:estructura_spd}.

\subsubsection{Archivo \texttt{.tcl}}

Hasta el momento hemos visto cómo crea un \textit{Data tree} (o árbol de datos), pero al cargar nuestro problem type (\texttt{Data$>$Problem type$>$}\textit{Seleccionar problem type de la lista}) la opción para abrirlo no se encuentra por ninguna parte. Esto es porque no hemos escrito nada en el archivo \texttt{.tcl} ni mucho menos \textbf{le hemos especificado al programa que lo abra}. Siguiendo los pasos de la Sección~\ref{sec:consideraciones} se detalla el código las funciones:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Código para inicializar el proyecto y crear el menú.}]
# Proyecto EjemploPT.gid

namespace eval EjemploPT {
	variable ptDir
}
proc InitGIDProject { dir } {
	EjemploPT::ModificarMenus
	EjemploPT::GuardarDirPT
	gid_groups_conds::open_conditions menu
}
proc EjemploPT::GuardarDirPT { dir } {
	variable ptDir
	set ptDir $dir
}
proc EjemploPT::ObtenerDirPT { } {
	variable ptDir
	return $ptDir
}
proc EjemploPT::BorrarDibujos { } {
	
	GidUtils::DisableGraphics
	foreach type { volume surface line point } {
		GiD_Geometry delete $type 1:end
	} 
	GidUtils::EnableGraphics
}
proc EjemploPT::ModificarMenus { } {
	GiDMenu::InsertOption "Data" [list "Mostrar data tree"] 0 PRE [list gid_groups_conds::open_conditions menu] "" "" replace =
	GiDMenu::InsertOption "Data" [list "Dibujar trabes"] 1 PRE [list EjemploPT::DibujarTrabe] "" "" replace =
    GiDMenu::UpdateMenus
}
\end{lstlisting}

\begin{itemize}
	\item \textcolor{blue}{\texttt{namespace eval EjemploPT}}: Crea el namespace y aloja espacio para la variable global de la dirección del problem type.
	\item \textcolor{blue}{\texttt{InitGIDProject}}: Evento que se ejecuta al abrir el problem type.
	\item \textcolor{blue}{\texttt{EjemploPT::ModificarMenus}}: Crea un \textbf{submenú} para ejecutar el dibujo paramétrico.
	\item \textcolor{blue}{\texttt{EjemploPT::GuardarDirPT}}: Almacena la dirección que \textcolor{blue}{\texttt{InitGIDProject}} le pasa como argumento.
	\item \textcolor{blue}{\texttt{proc EjemploPT::ObtenerDirPT}}: Regresa la dirección.
	\item \textcolor{blue}{\texttt{EjemploPT::BorrarDibujos}}: Borra todos las entidades (puntos, líneas, superficies y volúmenes) del dibujo. 
	\item \textcolor{blue}{\texttt{gid\_groups\_conds::open\_conditions menu}}: Abre el árbol de datos.	
\end{itemize}

Las siguientes instrucciones:
\begin{enumerate}
	\item \textcolor{blue}{\texttt{GiDMenu::InsertOption}}
	\item \textcolor{blue}{\texttt{GiDMenu::UpdateMenus}}
\end{enumerate}

Son rutinas definidas en GiD (consultar sección \textit{8.6 Managing menus} del \textit{Customization Manual}). La primera sirve para agregar submenús en el menú \textit{Data} de GiD, en este caso se agregó un submenú para abrir el \textit{árbol de datos} y otro submenú para dibujar (función \textcolor{blue}{\texttt{EjemploPT::DibujarTrabe}} más adelante). La segunda, para actualizar los cambios realizados. Si guardamos los cambios en el archivo y ejecutamos el problem type, se abrirá esta ventana:

\begin{figure}[hbtp!]\centering
	\includegraphics[width=0.2\textwidth]{captura_data_tree.PNG}
	\caption{Estructura del archivo \texttt{.spd} vista en el árbol de datos de GiD.\label{fig:captura_data_tree}}
\end{figure}

Si se ha mostrado la figura anterior, todo se ha cargado con éxito. Pero al seleccionar el submenú ``Dibujar trabes'' se generará un error como el que sigue:

\begin{figure}[hbt!]\centering
	\includegraphics[width=0.35\textwidth]{error_ListaTrabes.PNG}
	\caption{Error cuando GiD no encuentra definida una función.\label{fig:error_ListaTrabes}}
\end{figure}

Esto ocurre cuando GiD invoca a una función que no está definida en el archivo TCL. El siguiente paso es definir la función y sus componentes. Uno de los atributos de la etiqueta \texttt{$<$value$>$} es ``\texttt{values}'' (Sección~\ref{subsubsec:value}) la cual transforma el campo de \texttt{value} en lista desplegable si se entrega una cadena de caracteres separados por comas. Entonces la función \textcolor{blue}{\texttt{ListaTrabes}} deberá regresar una lista (se deberá escribir después de \texttt{InitGIDProject}

\lstset{language=tcl} 
\begin{lstlisting}
proc EjemploPT::ListaTrabes { domNode args } {
	return [list Tipo I , Tipo II , Tipo III , Tipo IV , Tipo V , Tipo VI]
}
\end{lstlisting}

Se guardan los cambios y ahora sí se puede abrir la lista desplegable del \textit{árbol de datos}.

\begin{figure}[hbt!]\centering
	\includegraphics[width=0.25\textwidth]{lista_desplegable.PNG}
	\caption{Lista desplegable con los tipos de trabes.\label{fig:lista_desplegable}}
\end{figure}

Ahora se necesita crear la base de datos de las trabes, para ello se crear una carpeta en el directorio del problem type llamada \texttt{xml} en el directorio del problem type (\texttt{EjemploPT.gid\textbackslash xml}) y almacenamos ahí el archivo (\texttt{basedatostrabes.xml}) donde estará los datos de la geometría (\texttt{blockdata}). El archivo ubicado en \texttt{EjemploPT.gid\textbackslash xml\textbackslash basedatostrabes.xml} quedaría de la siguiente manera (ver Anexo~\ref{app:catalogo}):


\lstset{language=XML} 
\begin{lstlisting}[caption={Extracto de la base de datos de la geometría.}]
<?xml version="1.0" encoding="utf-8"?>
<container n="basedatostrabes" pn="Geometria Trabes">
	<blockdata n="seccion" name="Tipo I">
		<value n='d1' pn='D1' v='71'/>
		<value n='d2' pn='D2' v='10'/>
		<value n='d3' pn='D3' v='0'/>
		<value n='d4' pn='D4' v='7.6'/>
		<value n='d5' pn='D5' v='13'/>
		<value n='d6' pn='D6' v='13'/>
		<value n='b1' pn='B1' v='30'/>
		<value n='b2' pn='B2' v='41'/>
... etc
</container>
\end{lstlisting}

Continuando con la escritura del archivo \texttt{.tcl}. Se deben hacer dos cosas:

\begin{enumerate}
	\item Obtener el valor del tipo de trabe que seleccione el usuario desde el archivo \texttt{EjemploPT\_default.spd}.
	\item Comparar ese valor con la etiqueta \textcolor{blue}{\texttt{name=}} coincidente de la base de datos y almacenar los datos.
\end{enumerate}

La obtención se lleva a cabo usando el paquete \textbf{tdom} al principio del código:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Código para inicializar el proyecto y crear el menú.}]
# Proyecto EjemploPT.gid
package require tdom; # Maneja el doc. XML
namespace eval EjemploPT {
	variable ptDir
}
...
\end{lstlisting}

Se escribe la función \textcolor{blue}{\texttt{EjemploPT::DibujarTrabe}} tomando en cuenta el uso se las \textit{listas} de TCl, el dibujo de geometrías mediante línea de código usando \textbf{GiD\_Process} (visto en la Sección~\ref{sec:GiDProcess}) y la manipulación de un archivo XML interno (\texttt{EjemploPT\_default.spd}) y externo (\texttt{basedatostrabes.xml}) donde para este último se hace uso de las funciones del parser \textit{tdom} y no de las funciones de \textit{CustomLib}.

Se tiene que resaltar que la instrucción:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Obtener el nodo raíz del archivo \texttt{basedatostrabes.xml}.}]
	set XPathBaseDatos [dom parse [tDOM::xmlReadFile [file join [EjemploPT::ObtenerDirPT] "xml/basedatostrabes.xml"]]]
\end{lstlisting}

hace lo mismo que:

\lstset{language=tcl} 
\begin{lstlisting}[caption={Obtener el nodo raíz del archivo \texttt{EjemploPT\_default.spd}.}]
	set rootSPD [customlib::GetBaseRoot]
\end{lstlisting}

Sin embargo la primera lee un archivo externo, la explicación es la siguiente: \textcolor{blue}{\texttt{dom parse}} crea un DOM (document object model) de un archivo como argumento, \textcolor{blue}{\texttt{tDOM::xmlReadFile}} lee un archivo XMl dada una dirección absoluta, misma que se obtiene al unir (\textcolor{blue}{\texttt{file join}}) la dirección del problem type (\textcolor{blue}{\texttt{EjemploPT::ObtenerDirPT}}) con la dirección donde colocamos \texttt{basedatostrabes.xml}.

\subsubsection{Código de \texttt{EjemploPT::DibujarTrabe}}
\lstset{language=tcl} 
\begin{lstlisting}[caption={Definición del procedimiento \texttt{EjemploPT::DibujarTrabe}}]
proc EjemploPT::DibujarTrabe { } {
	
	EjemploPT::BorrarDibujos
	set long 1000.00; # Longitud
	set factor 2.54; # Pulg. a cm.
	set sep 50.0; # Sep. entre trabes
	
	set rootSPD [customlib::GetBaseRoot]
	set tipoTrabe [get_domnode_attribute [$rootSPD selectNodes "\container\[@n='tipoTrabe'\]/value\[@n='tipo'\]"] v]
	
	set XPathBaseDatos [dom parse [tDOM::xmlReadFile [file join [EjemploPT::ObtenerDirPT] "xml/basedatostrabes.xml"]]]
	set domTipoTrabe [$XPathBaseDatos selectNodes "//container\[@n='basedatostrabes'\]"]
	
	foreach domTipoTrabe [$domTipoTrabe childNodes] {
		set strComp [$domTipoTrabe @name]
		if { [string match $tipoTrabe $strComp ] == 1 } {
			set nodoTipo $domTipoTrabe
			break
		}
	}
	
	# Dimension D
	set d1 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='d1'\]"] v]]
	set d2 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='d2'\]"] v]]
	set d3 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='d3'\]"] v]]
	set d4 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='d5'\]"] v]]
	set d5 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='d4'\]"] v]]
	set d6 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='d6'\]"] v]]
	# Dimension B
	set b1 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='b1'\]"] v]]
	set b2 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='b2'\]"] v]]
	set b3 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='b3'\]"] v]]
	set b4 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='b4'\]"] v]]
	set b5 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='b5'\]"] v]]
	set b6 [expr $factor*[get_domnode_attribute [$nodoTipo selectNodes "value\[@n='b6'\]"] v]]
	
	GidUtils::DisableGraphics
	if { $tipoTrabe!="Tipo V" || $tipoTrabe!="Tipo V" } {
		GiD_Process Mescape Geometry Create Line 0.0,0.0 \
			[expr $b1/2.0],0.0 \
			[expr $b1/2.0],[expr -$d2] \
			[expr $b3/2.0],[expr -$d2-$d4] \
			[expr $b3/2.0],[expr -$d1+$d5+$d6] \
			[expr $b2/2.0],[expr -$d1+$d6] \
			[expr $b2/2.0],[expr -$d1] \
			0.0,[expr -$d1] escape
		GiD_Process Mescape Utilities Copy Lines MaintainLayers Mirror FNoJoin 0.0,0.0,0.0 FNoJoin 0.0,1.0,0.0 TwoDim 1:7 escape
		GiD_Process Mescape Geometry Create NurbsSurface 1:14 escape
	} else {
		GiD_Process Mescape Geometry Create Line 0.0,0.0 \
			[expr $b1/2.0],0.0 \
			[expr $b1/2.0],[expr -$d2] \
			[expr $b1/2.0-$b5],[expr -$d2-$d3] \
			[expr $b3/2.0],[expr -$d2-$d3-$d4] \
			[expr $b3/2.0],[expr -$d1+$d5+$d6] \
			[expr $b2/2.0],[expr -$d1+$d6] \
			[expr $b2/2.0],[expr -$d1] \
			0.0,[expr -$d1] escape
		GiD_Process Mescape Utilities Copy Lines MaintainLayers Mirror FNoJoin 0.0,0.0,0.0 FNoJoin 0.0,1.0,0.0 TwoDim 1:8 escape
		GiD_Process Mescape Geometry Create NurbsSurface 1:16 escape
	}
	GiD_Process Mescape Utilities Copy Surfaces DoExtrude Volumes MaintainLayers Translation FJoin 1 FNoJoin 0.0,0.0,[expr -$long] 1 escape
	GiD_Process Mescape Utilities Copy Volumes MaintainLayers MCopy 5 Translation FJoin 1 FNoJoin [expr $b1+$sep],0.0,0.0 1 escape
	GidUtils::EnableGraphics
	GiD_Process Mescape
	GiD_Process Mescape 'Rotate Angle 270 90
	GiD_Process Mescape 'Zoom Frame
}
\end{lstlisting}

\subsection{Resultado}

Guardados los cambios se ejecuta el problem type. Para ver el resultado se abre el árbol de datos (\textit{Data}>\textit{Mostrar data tree}, o también abrirá automáticamente al cargar el problem type) y selecciona un tipo de trabe de la lista desplegable. Luego ejecutar el submenú \textit{Dibujar trabes} (\textcolor{blue}{\texttt{EjemploPT::DibujarTrabe}}). El resultado debe ser el siguiente:

\begin{figure}[hbt!]\centering
	\includegraphics[scale=.5]{trabes.PNG}
	\caption{Resultado de \textcolor{blue}{\texttt{EjemploPT::DibujarTrabe}} con una sección AASHTO Tipo V.\label{fig:resultadotrabes}}
\end{figure}

%----------------------------------------------------------------------------------------
%	APPENDIX
%----------------------------------------------------------------------------------------

\newpage
\appendix

\section{Anexo I: Catálogo de trabes \texttt{basedatostrabes.xml}} \label{app:catalogo}
\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>

<container n="basedatostrabes" pn="Geometria Trabes">
	<blockdata n="seccion" name="Tipo I">
		<value n='d1' pn='D1' v='71'/>
		<value n='d2' pn='D2' v='10'/>
		<value n='d3' pn='D3' v='0'/>
		<value n='d4' pn='D4' v='7.6'/>
		<value n='d5' pn='D5' v='13'/>
		<value n='d6' pn='D6' v='13'/>
		<value n='b1' pn='B1' v='30'/>
		<value n='b2' pn='B2' v='41'/>
		<value n='b3' pn='B3' v='15'/>
		<value n='b4' pn='B4' v='7.6'/>
		<value n='b5' pn='B5' v='0'/>
		<value n='b6' pn='B6' v='13'/>
	</blockdata>
	<blockdata n="seccion" name="Tipo II">
		<value n='d1' pn='D1' v='91'/>
		<value n='d2' pn='D2' v='15'/>
		<value n='d3' pn='D3' v='0'/>
		<value n='d4' pn='D4' v='7.6'/>
		<value n='d5' pn='D5' v='15'/>
		<value n='d6' pn='D6' v='15'/>
		<value n='b1' pn='B1' v='30'/>
		<value n='b2' pn='B2' v='46'/>
		<value n='b3' pn='B3' v='15'/>
		<value n='b4' pn='B4' v='7.6'/>
		<value n='b5' pn='B5' v='0'/>
		<value n='b6' pn='B6' v='15'/>
	</blockdata>
	<blockdata n="seccion" name="Tipo III">
		<value n='d1' pn='D1' v='114'/>
		<value n='d2' pn='D2' v='18'/>
		<value n='d3' pn='D3' v='0'/>
		<value n='d4' pn='D4' v='11'/>
		<value n='d5' pn='D5' v='19'/>
		<value n='d6' pn='D6' v='18'/>
		<value n='b1' pn='B1' v='41'/>
		<value n='b2' pn='B2' v='56'/>
		<value n='b3' pn='B3' v='18'/>
		<value n='b4' pn='B4' v='11'/>
		<value n='b5' pn='B5' v='0'/>
		<value n='b6' pn='B6' v='19'/>
	</blockdata>
	<blockdata n="seccion" name="Tipo IV">
		<value n='d1' pn='D1' v='137'/>
		<value n='d2' pn='D2' v='20'/>
		<value n='d3' pn='D3' v='0'/>
		<value n='d4' pn='D4' v='15'/>
		<value n='d5' pn='D5' v='23'/>
		<value n='d6' pn='D6' v='20'/>
		<value n='b1' pn='B1' v='51'/>
		<value n='b2' pn='B2' v='66'/>
		<value n='b3' pn='B3' v='20'/>
		<value n='b4' pn='B4' v='15'/>
		<value n='b5' pn='B5' v='0'/>
		<value n='b6' pn='B6' v='23'/>
	</blockdata>
	<blockdata n="seccion" name="Tipo V">
		<value n='d1' pn='D1' v='160'/>
		<value n='d2' pn='D2' v='13'/>
		<value n='d3' pn='D3' v='7.6'/>
		<value n='d4' pn='D4' v='10'/>
		<value n='d5' pn='D5' v='25'/>
		<value n='d6' pn='D6' v='20'/>
		<value n='b1' pn='B1' v='107'/>
		<value n='b2' pn='B2' v='71'/>
		<value n='b3' pn='B3' v='20'/>
		<value n='b4' pn='B4' v='10'/>
		<value n='b5' pn='B5' v='33'/>
		<value n='b6' pn='B6' v='25'/>
	</blockdata>
	<blockdata n="seccion" name="Tipo VI">
		<value n='d1' pn='D1' v='183'/>
		<value n='d2' pn='D2' v='13'/>
		<value n='d3' pn='D3' v='7.6'/>
		<value n='d4' pn='D4' v='10'/>
		<value n='d5' pn='D5' v='25'/>
		<value n='d6' pn='D6' v='20'/>
		<value n='b1' pn='B1' v='107'/>
		<value n='b2' pn='B2' v='71'/>
		<value n='b3' pn='B3' v='20'/>
		<value n='b4' pn='B4' v='10'/>
		<value n='b5' pn='B5' v='33'/>
		<value n='b6' pn='B6' v='25'/>
	</blockdata>
</container>
\end{lstlisting}
%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\begin{thebibliography}{1}
\bibitem{customizationmanual} 
GiD Team. 
\textit{Customization Manual}. 
Centro Internacional de Métodos Numéricos en Ingeniería, 2016.

\bibitem{aashtosections} 
AASHTO/PCI Standard Products. 
\textit{PCI Bridge Design Manual}. 
PCI Standard Products.

\bibitem{cdataref}
Wikipedia.
\textit{CDATA}.
Wikipedia, Creative Commons.

\bibitem{xml}
``¿Qué es XML?'', Página web. \textit{http://www.mundolinux.info/que-es-xml.htm}.
Mundo Linux.



\end{thebibliography}


\end{document}
