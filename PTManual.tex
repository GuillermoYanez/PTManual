\documentclass[10pt, a4paper, twocolumn]{article} % 10pt font size (11 and 12 also possible), A4 paper (letterpaper for US letter) and two column layout (remove for one column)

\input{structure.tex} % Specifies the document structure and loads requires packages

%----------------------------------------------------------------------------------------
%	ARTICLE INFORMATION
%----------------------------------------------------------------------------------------

\title{Primer acercamiento al desarrollo de Problem Types en GiD} % The article title

\author{
	\authorstyle{Luis G. Yáñez Rodríguez\textsuperscript{1}} % Authors
	\newline\newline % Space before instittions
	\textsuperscript{1}\institution{Universidad de Guanajuato, Guanajuato, México}\\ % Institution 1
}

% Example of a one line author/institution relationship
%\author{\newauthor{John Marston} \newinstitution{Universidad Nacional Autónoma de México, Mexico City, Mexico}}

\date{Febrero, 2018} % Add a date here if you would like one to appear underneath the title block, use \today for the current date, leave empty for no date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title

\thispagestyle{firstpage} % Apply the page style for the first page (no headers and footers)

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\lettrineabstract{Sin duda alguna, los modelos computacionales nos han permitido entender el mundo que nos rodea. Ya sea para explicar de una mejor manera un fenómeno o para poder predecirlo. Parte del éxito de estas soluciones tiene que ver con que estas se apoyan de elementos gráficos para la presentación de resultados, en resumen tener algo más o menos ``tangible'', ya que todas las soluciones que en estos métodos se encuentran se resumen en ceros y unos. Existen muchos softwares que ayudan en el pre y post proceso de un método computacional, pero entre ellos destaca uno en particular llamado GiD, The personal pre and post processor, desarrollado por el CIMNE, el cual que permite una amplia adaptación al problema en cuestión y customización de los procesos del modelado matemático.}

\section{Justificación}

Cuando se usa GiD para un análisis en particular, es necesario establecer los parámetros a los que el modelo estará sujeto (preproceso). En esta parte se definen parámetros como, condiciones, materiales, datos generales, sistema de unidades, símbolos y el formato del archivo de salida para el solver\footnote{Conjunto de rutinas de programación para resolver un problema numérico en específico.}. Gracias a la característica de adaptación de \textit{GiD}, los desarrolladores del software crearon una colección de archivos llamada \textbf{Problem Type} que definen los parámetros anteriores. Actualmente la documentación disponible acerca del desarrollo de problem types se encuentra en el idioma inglés, lo cual puede ser una limitante para aquellos que quieran incursionar en el desarrollo de las herramientas. 

\begin{figure}[hbt!]\centering
	\includegraphics[width=0.2\textwidth]{logoGiD.PNG}
	\caption{Logo de GiD.}
\end{figure}

\subsection{Objetivo}

Este documento pretende ser un ``primer acercamiento'' a los problem types para aquellas personas de habla hispana en donde tal vez no encuentren toda la información, pero sí puedan tener un apoyo.

\subsection{Aplicación}

Cabe señalar que este material será sólo un apoyo para la \textit{customización}, no es un manual de usuario de GiD, este se puede encontrar en \textcolor{BlueGiD}{\underline{\url{www.gidhome.com/support/gid-manuals/}}} . En caso de tener dudas muy puntuales el material de apoyo es muy amplio y siempre se puede consultar el \textit{Manual de Customización} o directamente en los foros de ayuda en donde los desarrolladores de GiD ayudarán, el link es \textcolor{BlueGiD}{\underline{\url{www.gidhome.com/forum/}}}.

\section{Primeros pasos}
\label{sec:manualTCL}
¿Qué es lo que hace interesante GiD?. La respuesta es la \textbf{programación}, GiD está escrito para que sea de propósito general, de manera que los usuarios pueden crear sus propios solvers y manipular la información que sale y entra en él. Para explicar lo anterior, se tiene el siguiente diagrama:

\begin{figure}[hbt!]\centering
	\includegraphics[width=0.35\textwidth]{etapasGiD.PNG}
	\caption{Diagrama de los procesos que realiza un Problem Type.}
	\label{fig:diagramaProcesos}
\end{figure}

La manera como se escribían anteriormente los \textit{problem types} era un poco rudimentaria, de manera que con unas cuantas instrucciones se desplegaban ventanas para la entrada de datos, imposibilitando personalizar estas ventanas.

Desde la versión 13 de GiD, se ha implementado una nueva versión de problem type (basado en la librería CustoLIB), aunque el sistema ``clásico'' sigue siendo soportado por GiD. Esta nueva versión usa un único archivo \texttt{.spd} para describir las propiedades generales, materiales, condiciones y unidades (como un árbol en la sintaxis de \textbf{XML}). Toda esta información se muestra en una ``vista de árbol'' y los materiales y condiciones son asociados en grupos de entidades.

Toda esta información es leída y procesada mediante el lenguaje de programación \textbf{TCL}, lenguaje orientado a objetos que permitirá crear interfaces gráficas de usuario (GUI) y darle un mejor aspecto a los problem types.

La combinación de TCL y XML, definirá el rumbo que el usuario le de a su problem type, es por ello que es importante leer y aprender de estas dos herramientos. Una buena guía para TCL se puede encontrar en: \textcolor{BlueGiD}{\underline{\url{www.tcl.tk/doc/}}}, y para XML en: \textcolor{BlueGiD}{\underline{\url{www.w3schools.com/xml/}}}.

\subsection{El sistema del problem type}

Como ya se dijo, un problem type es una colección de utilidades, las cuales permiten al usuario interactuar fácilmente con ellos mediante una GUI y facilita la definición e introducción de todos los datos necesarios para abordar un cálculo en particular. Para preparar los tos para un programa de análisis específicos, es necesario personalizarlo primero. La personalización se define en GiD por medio de un problem type.

El nuevo sistema para la creación de un problem type agrega algunas capacidades adicionales comparado con el sistema clásico:

\begin{itemize}
	\item Aprovecha las características de formato de XML y su estructura jerarquizada. Almacena información eficientemente. Los elementos en un documento XML forman una estructura de árbol que ``comienza en la raíz y se ramifica en las hojas'' con diferentes relaciones entre los elementos anidados.
	\item Facilita la creación automática de \textit{ventanas estandarizadas} en el árbol de datos (\textit{data tree}) para introducir datos.
	\item Permite acoplar entidades con propiedades idénticas en grupos.
	\item Permite aplicar eficientemente propiedades geométricas y condiciones de contorno en grupos para editar sus propiedades fácilmente.
\end{itemize}

\subsection{Notepad++}
Dada la premisa de que para trabajar en GiD utilizaremos dos lenguajes (XML y TCL), necesitamos una herramienta que nos permita una escritura de código versátil. Existen editores de texto que brindan soporte para los diferentes lenguajes de programación es decir, cuando se crea un archivo con extensión \textbf{\texttt{.cpp}} (C++), \textbf{\texttt{.java}} (Java), \textbf{\texttt{.m}} (MATLAB/Octave), el editor detecta las palabras reservadas del lenguaje en cuestión. Una muy buena opción es \textbf{Notepad++}, un libre editor de código fuente que se puede encontrar en:\\ 

\textcolor{BlueGiD}{\underline{\url{www.notepad-plus-plus.org/download/}}}\\

Cabe mencionar que GiD tiene su editor de TCL incluido (\textit{Data}>\textit{Problem type}>\textit{Debugger...}) sin embargo prefiero usar Notepad++ por su gran eficiencia.

Se utilizará este editor para crear, editar y organizar los archivos que componen el problem type.

\subsection{Mini-tutorial de XML}

\begin{itemize}
	\item ¿QUÉ ES XML?
		\begin{itemize}
			\item XML significa eXtensible Markup Language.
			\item Es un meta-lenguaje que permite representar información estructurada de modo que esta pueda ser almacenada, transmitida, procesada, visualizada e impresa, por diversos dispositivos a través de un \textit{analizador sintáctico}.
		\end{itemize}
	\item ¿QUÉ NO ES XML?
		\begin{itemize}
			\item No es una versión mejorada de HTML.
			\item No es un lenguaje para hacer páginas Web.
			\item No es difícil.
		\end{itemize}
	\item ¿POR QUÉ XML?
		\begin{itemize}
			\item Es un estándar internacionalmente conocido.
			\item No pertenece a ninguna compañía.
		\end{itemize}
\end{itemize}

Este es un ejemplo de cómo luce un XML. Gracias a su característica de marcado, puede ser interpretado por una computadora y por humanos. La primera línea es de carácter obligatorio ya que define los parámetros de lectura del intérprete.

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<!-- Esto es un comentario -->
<IntegrantesAulaCIMNEUG>
  <integrante tipo="colaborador">
    <nombre>Luis Guillermo</nombre>
    <grado>Pasante de Ingenieria</grado> 
  </integrante>

  <integrante tipo="responsable">
    <nombre>Humberto Esqueda</nombre>
    <grado>Maestro en Ciencias</grado> 
  </integrante>
</IntegrantesAulaCIMNEUG>
\end{lstlisting}

\subsection{Mini-tutorial de TCL}

\lstset{language=tcl} 

\begin{itemize}
\item Asignar valor a una variable:
\begin{lstlisting}
set entero 1; # Valor entero
set flot 1.0; # Valor flotante 
\end{lstlisting}

\item Asignar valor de una variable a otra:
\begin{lstlisting}
set entero1 "Hola mundo!"; # Uso de cadenas de texto
set entero2 $entero1; # Asignar valor a variable
\end{lstlisting}

\item Operaciones matemáticas:
\begin{lstlisting}
set tres 3.0
set suma [expr 1.0+2.0+$tres]; # Sumar numeros con variables
\end{lstlisting}

\item Crear funciones o procedimientos (\textbf{\texttt{proc}}):
\begin{lstlisting}
proc FuncionSuma { arg1 arg2 } {
	return [expr $arg1+$arg2]; # Regresa suma de dos numeros
}
proc ProgramaPrincipal { } {
	set num1 37.0; # Valor flotante 
	set num2 45.65; # Valor flotante 
	set resultado [FuncionSuma $num1 $num2]; # Se utilizan corchetes para invocar otros programas
	puts $resultado; # Imprimir en pantalla el resultado
}

\end{lstlisting}

\end{itemize}

\subsection{Estructura del problem type}

Un problem type se define creando una carpeta cuyo nombre será el nombre del problem type propiamente, seguido de la extensión ''\textbf{.gid}´´ y en esta se colocarán una serie de archivos que tendrán una estructura específica. Para ejemplificar este \textit{manual} se creará uno llamado \textbf{\texttt{EjemploPT.gid}}.

La carpeta del problem type estará ubicada en el directorio \textbf{problemtypes} de la distribución \textit{GiD} que se tenga instalado en la computadora, por ejemplo en caso que sea la versión \texttt{13.1.0d} en Windows, se debe colocar la carpeta \textbf{\texttt{EjemploPT.gid}} en la dirección:

\begin{verbatim}
	C:\Program Files\GiD\GiD 13.1.0d\problemtypes
\end{verbatim}

Una vez colocada la carpeta en la dirección anterior, crearemos con ayuda de \textbf{Notepad++} y colocaremos en \textbf{\texttt{EjemploPT.gid}} los siguientes archivos:

\begin{table}[hbtp!]
	\label{tab:estructuraArchivos}
	\begin{tabular}{l m{4.5cm}}
		\rowcolor{BlueGiD!60} Nombre del archivo & Descripción\\
		\rowcolor{BlueGiD!20} EjemploPT.spd & Archivo de configuración principal del árbol de datos, basado en \textbf{XML}.\\
		EjemploPT.tcl & Archivo \textbf{TCL} principal, inicialización.\\
		\rowcolor{BlueGiD!20} EjemploPT.cnd & Definición de condiciones. No debería modificarlo el usuario final.\\
		EjemploPT.xml & Define la configuración principal del problemtype.\\
	\end{tabular}
	\caption{Archivos contenidos en \textbf{\texttt{EjemploPT.gid}} para inicializar el problem type.}
\end{table}

De modo que el directorio del problem type se vería así:

\begin{verbatim}
	EjemploPT.gid
	EjemploPT.gid\EjemploPT.spd
	EjemploPT.gid\EjemploPT.tcl
	EjemploPT.gid\EjemploPT.cnd
	EjemploPT.gid\EjemploPT.xml
\end{verbatim}

Teniendo esto, abrimos \textit{GiD}, en el menú \textit{Data}>\textit{Problem type} se debe encontrar el problem type \textbf{\texttt{EjemploPT}}. Si al seleccionarlo no se ha producido ningún error, \textbf{los archivos se han cargado satisfactoriamente}.

\section{Estructura de los archivos}

En esta sección hablaré de la estructura y parámetros de configuración adecuados a los archivos que se describieron en \ref{tab:estructuraArchivos} para comenzar la personalización de GiD.

\subsection{EjemploPT.xml}

El archivo de configuración inicial XML, contiene datos generales del programa. Este archivo generalmente sólo se configura una sóla vez, ya que los datos sólo son informativos.

Aunque el archivo es muy corto, la información es esencial, no se debe omitir ninguna de estas etiquetas ni modificar los identificadores. Existen más etiquetas para darle más información a GiD sobre nuestro problem type, pero estas son de uso \textbf{obligatorio}.

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<Infoproblemtype version="1.0">
  <Program>
    <Name>EjemploPT</Name>
    <Version>1.0</Version>   
    <MinimumGiDVersion>12.1.11d</MinimumGiDVersion>
    <CustomLibAutomatic>1</CustomLibAutomatic>
 </Program>
</Infoproblemtype>
\end{lstlisting}

\textcolor{red}{NOTA:} Cabe señalar que la \textit{etiqueta} \texttt{\textcolor{darkblue}{CustomLibAutomatic}} debe tener el valor de \texttt{\textcolor{darkblue}{1}} (uno). Este activa el uso de la librería \textit{CustomLib} que permite acceder a funciones del nuevo sistema de problem types.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Al escribir esto en el archivo XML, se guardan los cambios en el archivo.

\subsection{EjemploPT\_default.spd}

Este archivo establece la configuración principal del \textit{Árbol de datos} (\textit{Data tree}, en inglés), cuyo fin es estructural las condiciones, materiales y otros datos del modelo computacional.

Como se dijo en \ref{tab:estructuraArchivos}, está basado en XML y los \textit{campos}, \textit{atributos} y otros identificadores que debe contener \textbf{ya están establecidos por GiD} para que el software los interprete y posteriormente crear elementos gráficos con ellos.

% Poner referencia del Customization_Manual.pdf
En XML podemos crear \textit{campos o etiquetas} con cualquier nombre, para almacenar diferentes datos estos identificadores. En la programación de problem types, los nombre de estos campos o etiquetas ya se encuentran reservados y son así para que el GiD pueda interpretarlos y este último pueda crear objetos gráficos. En la documentación de GiD se describe la estructura adecuada para estas \textit{etiquetas}.

Para ramificar el árbol de datos, estas etiquetas pueden anidarse para contener objetos dentro de otros. En este manual solo se describen algunas de ellas:

\subsubsection{$<$PT\_data$>$}

\vspace{0.20cm}
\begin{center}
	\texttt{$<$PT\_data$>$}
\end{center}
\vspace{0.20cm}

Es \textbf{etiqueta principal y obligatoria} del archivo \texttt{.spd}. Contiene el número de versión y el nombre del problem type. Los caracteres \texttt{PT} deben ser remplazados por el nombre del problem type.

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{version} - Número de versión interno.
\vspace{0.15cm}


Como el problem type se llama \texttt{EjemploPT}, el nodo principal es:

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>

<EjemploPT_data version='1.0'>
	...
</EjemploPT_data>
\end{lstlisting}

\subsubsection{$<$container$>$}

\vspace{0.20cm}
\begin{center}
	\texttt{$<$container$>$}
\end{center}
\vspace{0.20cm}


Es la forma más simple de agrupar datos y mejorar su visualización. En la ventana resultante, además de las entradas, se encontrarán los siguientes botones:

\begin{figure}[hbtp!]
	\centering
	\includegraphics[scale=1]{container.png}
\end{figure}

Puede contener o anidarse en esta etiqueta los siguientes campos: \texttt{<value>}, \texttt{<container>}, \texttt{<condition>}, \texttt{<functions>} y \texttt{<dependencies>} (en este manual no se definirán todas las etiquetas).

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{n} - Nombre usado para referenciar el campo, especialmente cuando se escriben los arhivos \texttt{.dat} y \texttt{.tcl}.\\
	\textbf{pn} - Etiqueta que será visualizada por el usuario.\\
	\textbf{icon} - Permite poner una imagen en formato \texttt{.png} en el \textit{data tree}- La imagen debe ser guardada dentro de la carpeta llamada \texttt{images} del problem type.\\
	\textbf{help} - Despliega una ventana \textit{pop-up} con información de ayuda relacionada a la tarea que el usuario desea realizar. Aparece a los pocos segundos de posicionar el cursor en el container.\\
	\textbf{actualize\_tree} - Actualiza la información que contiene en todo el \textit{data tree} y automáticamente actualiza los datos mostrados en la interfaz del usuario. Es un valor booleano de 1 o 0 indicado si está activada o desactivada esta función.
\vspace{0.15cm}

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>

<EjemploPT_data version="1.0">
	<container n="contenedor1" pn="Container 1" help="Esto es un ejemplo." actualize_tree="1">
		<container n="contenedor2" pn="Container 2" help="Containers anidados" actualize_tree="1">
			<value n="valor" pn="Valor" v="1.0"/>
		</container>
	</container>
</EjemploPT_data>
\end{lstlisting}

\subsubsection{$<$value$>$}

\vspace{0.20cm}
\begin{center}
	\texttt{$<$value$>$}
\end{center}
\vspace{0.20cm}

Es el campo principal para almacenar datos. Este campo permite definir una \textit{caja de entrada} en la ventana.

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{n} - Nombre usado para referenciar el campo, especialmente cuando se escriben los arhivos \texttt{.dat} y \texttt{.tcl}.\\
	\textbf{pn} - Etiqueta que será visualizada por el usuario.\\
	\textbf{v} - El valor o valor por defecto del campo.\\
\vspace{0.15cm}

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<container n="caja" pn="Caja">
  <value n="base" pn="Base:" v="5.00"/>
  <value n="altura" pn="Altura:" v="6.00"/>
</container>
\end{lstlisting}


\textit{Anidar} las etiquetas \texttt{$<$value$>$} en \texttt{$<$container$>$}, como el ejemplo anterior produce lo siguiente:

\begin{figure}[hbtp!]
	\centering
	\includegraphics[scale=.8]{value_field.png}
\end{figure}

\subsubsection{$<$procs$>$ y $<$proc$>$}

% INCLUIR BIBLIOGRAFÍA DE CDATA
\textcolor{red}{\textbf{¡IMPORTANTE!}:} Antes de explicar las etiquetas \texttt{$<$procs$>$} y \texttt{$<$proc$>$} se debe explicar el uso de las \textbf{secciones \texttt{CDATA}}. En un documento XML, una sección \texttt{CDATA} (del inglés, \textbf{character data}) es aquella perteneciente a un documento que es marcado para que el \textit{analizador sintáctico} lo interprete como una cadena de caracteres y no como contenido etiquetado. No hay diferencia semántica entre una cadena de caracteres dentro de una sección \texttt{CDATA} y la sintaxis usual en la que ``$<$'', ``$>$'' y ``$\&$'' estarían representados por ``\texttt{\&lt}'', ``\texttt{\&gt}'' y ``\texttt{\&amp}'' respectivamente.

Una sección \texttt{CDATA} empieza con la siguiente secuencia:

\begin{flushleft}
\begin{verbatim}
<![CDATA[
\end{verbatim}
\end{flushleft}

y termina con la primera ocurrencia de la secuencia:

\begin{flushleft}
\begin{verbatim}
]]>
\end{verbatim}
\end{flushleft}

los caracteres encapsulados dentro de estas dos secuencias son interpretados como caracteres, no como etiquetas o como referencia a entidades.

\lstset{language=XML} 
\begin{lstlisting}
<nombre>Luis Guillermo</nombre>
\end{lstlisting}

El texto contenido dentro de las etiquetas \textbf{\texttt{nombre}} es interpretado como elemento XML. Sin embargo si se escribe de esta manera:


\begin{verbatim}
<![CDATA[<nombre>Luis Guillermo</nombre>]]>
\end{verbatim}

Es interpretado como si se hubiera escrito así:

\begin{verbatim}
&lt;nombre&gt;Luis Guillermo&lt;/nombre&gt;
\end{verbatim}

¿Qué finalidad tiene esto?. Lo que interesa aquí, es que el texto contenido en una sección \texttt{CDATA} no sea leído por XML y sea interpretado por TCL. ¿Qué es eso que debe interpretar TCL y no XML?, TCL debe leer funciones de TCL. ¿Y cómo se le indica a TCL qué es lo que debe interpretar él y no XML?, mediante las etiquetas \texttt{$<$procs$>$} y \texttt{$<$proc$>$}. Todo aquello contenido dentro de estas últimas será leído por TCL.

\vspace{0.20cm}
\begin{center}
	\begin{tabular}{rcl}
		\texttt{$<$procs$>$} &y&\texttt{$<$proc$>$}\\
	\end{tabular}
\end{center}
\vspace{0.20cm}

La etiqueta \texttt{$<$procs$>$} \textbf{agrupa las declaraciones de los procedimientos} o funciones (\texttt{procs}) de TCL que se ejecutarán desde el árbol de datos. En cambio con la etiqueta \texttt{$<$proc$>$} \textbf{se declaran} como tal. En el archivo \texttt{.tcl} se definen, como veremos más adelante.

La etiqueta \texttt{$<$procs$>$} no lleva ningún atributo. La etiqueta \texttt{$<$proc$>$} lleva los siguientes atributos:

\vspace{0.15cm}
\textit{Atributos}:

\vspace{0.15cm}
	\textbf{n} - Nombre usado para referenciar el campo, especialmente cuando se escriben los arhivos \texttt{.dat} y \texttt{.tcl}.\\
	\textbf{args} - ``args'', el cual indica al intérprete de GiD que se introducirá información acerca de los nodos.\\
\vspace{0.15cm}

Sintetizando lo anterior, se muestra el siguiente ejemplo:

\lstset{language=XML} 
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<container n="caja" pn="Area rectangulo" actualize_tree="1">
  <value n="base" pn="Base" v="5.00" actualize_tree="1"/>
  <value n="altura" pn="Altura:" v="6.00"actualize_tree="1"/>
  <value n="area" pn="Area" v="[CalcularArea]" actualize_tree="1"/>
</container>
<procs>
  <proc n="calculararea" args="args">
    <![CDATA[
      CalcularArea $domNode $args
    ]]>
  </proc>
</procs>
\end{lstlisting}

Así, TCL podrá leer y ejecutar la función \texttt{CalcularArea} misma que deberá ser definida posteriormente en la sección siguiente.


\subsection{EjemploPT.tcl}

A diferencia de los archivos anteriores, que definen la estructura del problem type, el archivo \texttt{.tcl} define la lógica de esa estructura. El lenguaje de este archivo, como su extensión lo indica es \textbf{TCL/TK puro}. Toda la documentación acerca del lenguaje TCL se encuentra disponible en el manual que se mostró en la sección \ref{sec:manualTCL}.

\subsubsection{Eventos}
Como hemos visto anteriormente, hay etiquetas con un nombre específico que GiD interpreta para realizar diferentes acciones. Lo mismo sucede en el archivo \texttt{.tcl} pero con los \textbf{eventos}. Los eventos en la programación, son rutinas de código que se ejecutan cuando una acción se realiza durante el programa, mismas que el usuario invoca. Por ejemplo, cuando el usuario abre GiD, se deben ejecutar las funciones para cargar el área de dibujo, abrir la barra de herramientas, cargar el idioma y las preferencias del usuario,etc. Cuando se crea un problem type sucede lo mismo, pero a diferencia de los ejemplos anteriores, estas funciones ya se encuentran definidas por GiD y listas para editarse.

La guía del uso de estas funciones se encuentran en el \textit{Customization Manual} contenido en esta bibliografía, pero aquí se mencionan las más importantes:

\lstset{language=tcl} 
\begin{lstlisting}
proc InitGIDProject { dir } {
}
\end{lstlisting}

\textit{Descripción}: Será llamada cuando se seleccione el problem type. Recibe el argumento \texttt{dir}, el cual es la ruta absoluta del directorio del problem type. Puede ser útil guardar \texttt{dir} para posteriormente  acceder a otros archivos dentro del directorio.

\begin{lstlisting}
proc SaveGIDProject { filespd } {
}
\end{lstlisting}

\textit{Descripción}: Será llamada cuando el proyecto actual sea guardado en el disco duro. Recibe el argumento \texttt{filespd}, el cual es la ruta del archivo guardado, pero con extensión \texttt{.spd}.

\subsubsection{Programación en TCL}

Una vez seleccionadas las funciones que han de ejecutar, se deben escribir las funciones en TCL. Para ello se debe crear primero un \texttt{namespace}. Un \texttt{namespace} es un área de trabajo que permite particionar diferentes comandos y variables de otras áreas de trabajo. Esto será útil para separar las funciones que nosotros hemos de crear con las que ya están definidas por GiD y evitar la \textit{colisión de nombres}. Una vez creada el área de trabajo, podremos almacenar en esta todas nuestras variables y funciones propias del \texttt{namespace}.

Para crear un \texttt{namespace} se utiliza el siguiente comando:

\lstset{language=tcl} 
\begin{lstlisting}
namespace eval path {
}
\end{lstlisting}

Donde \texttt{path} será la ruta (o identificador) del área de trabajo, en este caso ponermos el \textbf{nombre del problem type}. Dentro de las llaves usualmente se declaran todas las variables globales que estarán durante todo el problem type. Por ejemplo, para crear un \texttt{namespace} para \texttt{EjemploPT} escribiremos en el archivo \texttt{.tcl} lo siguiente:

\lstset{language=tcl} 
\begin{lstlisting}
namespace eval EjemploPT {
	variable radio
}
\end{lstlisting}

Lo que hace el código anterior es crear el \texttt{namespace} para \texttt{EjemploPT} y crea una variable global llamada \texttt{radio}.

En este ejemplo se crea una función (o proc) llamada \textcolor{blue}{\texttt{CalcularAreaCirculo}} en el \texttt{namespace} de \texttt{EjemploPT}. Llama la variable global \texttt{radio} y almacena el valor de \texttt{5.00} y la función regresa el valor del área de un círculo:

\lstset{language=tcl} 
\begin{lstlisting}
proc EjemploPT::CalcularAreaCirculo { } {
	variable radio	
	set radio 5.00
	return [expr $radio*$radio*3.14159265359]
}
\end{lstlisting}

 
\section{Problem type: EjemploPT.gid}

Orientaré esta manual a solo un ejemplo: \textbf{hacer un problem type para dibujar un conjunto secciones de trabes AASHTO, seleccionando el tipo mediante listas desplegables en el árbol de datos}. Se trabajará únicamente con los archivos \texttt{.tcl} y \texttt{.spd} ya que el archivo \texttt{.xml} sólo es de configuración.

\subsection{Consideraciones generales}

Se



%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\section{Bibliografía}

%\printbibliography[title={Bibliography}] % Print the bibliography, section title in curly brackets

%----------------------------------------------------------------------------------------

\end{document}
